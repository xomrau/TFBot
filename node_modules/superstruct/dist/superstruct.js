(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Superstruct = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

/**
 * Module dependenices
 */

var isObject = require('is-plain-object');
var clone = require('shallow-clone');
var typeOf = require('kind-of');
var forOwn = require('for-own');

/**
 * Recursively clone native types.
 */

function cloneDeep(val, instanceClone) {
  switch (typeOf(val)) {
    case 'object':
      return cloneObjectDeep(val, instanceClone);
    case 'array':
      return cloneArrayDeep(val, instanceClone);
    default: {
      return clone(val);
    }
  }
}

function cloneObjectDeep(obj, instanceClone) {
  if (isObject(obj) || (instanceClone === true && typeOf(obj) === 'object')) {
    var res = {};
    forOwn(obj, function(val, key) {
      this[key] = cloneDeep(val, instanceClone);
    }, res);
    return res;
  }
  if (typeof instanceClone === 'function') {
    return instanceClone(obj);
  }
  return obj;
}

function cloneArrayDeep(arr, instanceClone) {
  var res = [];
  for (var i = 0; i < arr.length; i++) {
    res[i] = cloneDeep(arr[i], instanceClone);
  }
  return res;
}

/**
 * Expose `cloneDeep`
 */

module.exports = cloneDeep;

},{"for-own":3,"is-plain-object":5,"kind-of":7,"shallow-clone":9}],2:[function(require,module,exports){
/*!
 * for-in <https://github.com/jonschlinkert/for-in>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function forIn(obj, fn, thisArg) {
  for (var key in obj) {
    if (fn.call(thisArg, obj[key], key, obj) === false) {
      break;
    }
  }
};

},{}],3:[function(require,module,exports){
/*!
 * for-own <https://github.com/jonschlinkert/for-own>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var forIn = require('for-in');
var hasOwn = Object.prototype.hasOwnProperty;

module.exports = function forOwn(obj, fn, thisArg) {
  forIn(obj, function(val, key) {
    if (hasOwn.call(obj, key)) {
      return fn.call(thisArg, obj[key], key, obj);
    }
  });
};

},{"for-in":2}],4:[function(require,module,exports){
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isPlainObject = require('is-plain-object');

module.exports = function isExtendable(val) {
  return isPlainObject(val) || typeof val === 'function' || Array.isArray(val);
};

},{"is-plain-object":5}],5:[function(require,module,exports){
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = require('isobject');

function isObjectObject(o) {
  return isObject(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

module.exports = function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};

},{"isobject":6}],6:[function(require,module,exports){
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};

},{}],7:[function(require,module,exports){
var toString = Object.prototype.toString;

module.exports = function kindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';

  var type = typeof val;
  if (type === 'boolean') return 'boolean';
  if (type === 'string') return 'string';
  if (type === 'number') return 'number';
  if (type === 'symbol') return 'symbol';
  if (type === 'function') {
    return isGeneratorFn(val) ? 'generatorfunction' : 'function';
  }

  if (isArray(val)) return 'array';
  if (isBuffer(val)) return 'buffer';
  if (isArguments(val)) return 'arguments';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  if (isRegexp(val)) return 'regexp';

  switch (ctorName(val)) {
    case 'Symbol': return 'symbol';
    case 'Promise': return 'promise';

    // Set, Map, WeakSet, WeakMap
    case 'WeakMap': return 'weakmap';
    case 'WeakSet': return 'weakset';
    case 'Map': return 'map';
    case 'Set': return 'set';

    // 8-bit typed arrays
    case 'Int8Array': return 'int8array';
    case 'Uint8Array': return 'uint8array';
    case 'Uint8ClampedArray': return 'uint8clampedarray';

    // 16-bit typed arrays
    case 'Int16Array': return 'int16array';
    case 'Uint16Array': return 'uint16array';

    // 32-bit typed arrays
    case 'Int32Array': return 'int32array';
    case 'Uint32Array': return 'uint32array';
    case 'Float32Array': return 'float32array';
    case 'Float64Array': return 'float64array';
  }

  if (isGeneratorObj(val)) {
    return 'generator';
  }

  // Non-plain objects
  type = toString.call(val);
  switch (type) {
    case '[object Object]': return 'object';
    // iterators
    case '[object Map Iterator]': return 'mapiterator';
    case '[object Set Iterator]': return 'setiterator';
    case '[object String Iterator]': return 'stringiterator';
    case '[object Array Iterator]': return 'arrayiterator';
  }

  // other
  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
};

function ctorName(val) {
  return val.constructor ? val.constructor.name : null;
}

function isArray(val) {
  if (Array.isArray) return Array.isArray(val);
  return val instanceof Array;
}

function isError(val) {
  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function'
    && typeof val.getDate === 'function'
    && typeof val.setDate === 'function';
}

function isRegexp(val) {
  if (val instanceof RegExp) return true;
  return typeof val.flags === 'string'
    && typeof val.ignoreCase === 'boolean'
    && typeof val.multiline === 'boolean'
    && typeof val.global === 'boolean';
}

function isGeneratorFn(name, val) {
  return ctorName(name) === 'GeneratorFunction';
}

function isGeneratorObj(val) {
  return typeof val.throw === 'function'
    && typeof val.return === 'function'
    && typeof val.next === 'function';
}

function isArguments(val) {
  try {
    if (typeof val.length === 'number' && typeof val.callee === 'function') {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf('callee') !== -1) {
      return true;
    }
  }
  return false;
}

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer(val) {
  if (val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}

},{}],8:[function(require,module,exports){
'use strict';

var isObject = require('is-extendable');
var forIn = require('for-in');

module.exports = function mixin(target, objects) {
  if (!isObject(target)) {
    throw new TypeError('expected the first argument to be an object');
  }

  var len = arguments.length;
  var idx = 0;

  while (++idx < len) {
    copy(target, arguments[idx]);
  }
  return target;
};

/**
 * copy properties from the source object to the
 * target object. We don't use `Object.keys` here, since
 * "mixin" also adds non-enumerable keys.
 *
 * @param  {*} `value`
 * @param  {String} `key`
 */

function copy(target, obj) {
  if (isObject(obj)) {
    forIn(obj, function(value, key) {
      target[key] = value;
    });
  }
}

},{"for-in":2,"is-extendable":4}],9:[function(require,module,exports){
/*!
 * shallow-clone <https://github.com/jonschlinkert/shallow-clone>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

'use strict';

var isObject = require('is-extendable');
var mixin = require('mixin-object');
var typeOf = require('kind-of');

/**
 * Shallow copy an object, array or primitive.
 *
 * @param  {any} `val`
 * @return {any}
 */

function clone(val) {
  var type = typeOf(val);
  if (clone.hasOwnProperty(type)) {
    return clone[type](val);
  }
  return val;
}

clone.array = function cloneArray(arr) {
  return arr.slice();
};

clone.date = function cloneDate(date) {
  return new Date(+date);
};

clone.object = function cloneObject(obj) {
  if (isObject(obj)) {
    return mixin({}, obj);
  } else {
    return obj;
  }
};

clone.map = function cloneMap(val) {
  return new Map(val);
};

clone.regexp = function cloneRegExp(re) {
  var flags = '';
  flags += re.multiline ? 'm' : '';
  flags += re.global ? 'g' : '';
  flags += re.ignorecase ? 'i' : '';
  return new RegExp(re.source, flags);
};

clone.set = function cloneSet(val) {
  return new Set(val);
};

/**
 * Expose `clone`
 */

module.exports = clone;

},{"is-extendable":4,"kind-of":7,"mixin-object":8}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _kindOf = require('kind-of');

var _kindOf2 = _interopRequireDefault(_kindOf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Type strings.
 *
 * @type {Array}
 */

const TYPES = ['arguments', 'array', 'boolean', 'buffer', 'date', 'float32array', 'float64array', 'function', 'generatorfunction', 'int16array', 'int32array', 'int8array', 'map', 'null', 'number', 'object', 'regexp', 'set', 'string', 'symbol', 'uint16array', 'uint32array', 'uint8array', 'uint8clampedarray', 'undefined', 'weakmap', 'weakset'];

/**
 * Default types.
 *
 * @type {Object}
 */

const DEFAULT_TYPES = {
  any: value => value !== undefined,
  error: value => Object.prototype.toString.call(value) === '[object Error]'
};

TYPES.forEach(type => {
  DEFAULT_TYPES[type] = value => (0, _kindOf2.default)(value) === type;
});

/**
 * Export.
 *
 * @type {Object}
 */

exports.default = DEFAULT_TYPES;

},{"kind-of":7}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StructError = exports.superstruct = exports.struct = undefined;

var _structError = require('./struct-error');

var _structError2 = _interopRequireDefault(_structError);

var _superstruct = require('./superstruct');

var _superstruct2 = _interopRequireDefault(_superstruct);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Create a simple `struct` method for the default types.
 *
 * @type {Function}
 */

const struct = (0, _superstruct2.default)();

/**
 * Export.
 *
 * @type {Function}
 */

exports.struct = struct;
exports.superstruct = _superstruct2.default;
exports.StructError = _structError2.default;

},{"./struct-error":12,"./superstruct":13}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Define a struct error.
 *
 * @type {StructError}
 */

class StructError extends TypeError {

  constructor(code, data) {
    data.code = code;
    data.path = data.path || [];
    const { index, key, value, type } = data;
    let message;

    switch (code) {
      case 'element_invalid':
        message = `Expected the element at index \`${index}\` to be of type "${type}", but it was \`${value}\`.`;
        break;
      case 'property_invalid':
      case 'property_required':
        message = `Expected the \`${key}\` property to be of type "${type}", but it was \`${value}\`.`;
        break;
      case 'property_unknown':
        message = `Unexpected \`${key}\` property that was not defined in the struct.`;
        break;
      case 'value_invalid':
      case 'value_required':
        message = `Expected a value of type "${type}" but received \`${value}\`.`;
        break;
      default:
        throw new Error(`Unknown struct error code: "${code}"`);
    }

    super(message);
    this.name = 'StructError';
    this.errors = [this];

    for (const k in data) {
      this[k] = data[k];
    }

    Error.captureStackTrace(this, this.constructor);
  }

}

/**
 * Export.
 *
 * @type {StructError}
 */

exports.default = StructError;

},{}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _cloneDeep = require('clone-deep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _kindOf = require('kind-of');

var _kindOf2 = _interopRequireDefault(_kindOf);

var _defaultTypes = require('./default-types');

var _defaultTypes2 = _interopRequireDefault(_defaultTypes);

var _structError = require('./struct-error');

var _structError2 = _interopRequireDefault(_structError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A private string to identify structs by.
 *
 * @type {String}
 */

const IS_STRUCT = '@@__STRUCT__@@';

/**
 * Public methods for struct functions.
 *
 * @type {Array}
 */

const STRUCT_METHODS = ['assert', 'default', 'defaultProperty', 'mask', 'test', 'validate', 'validateElement', 'validateProperty'];

/**
 * The diffrent Kinds of struct schemas.
 *
 * @type {Array}
 */

const STRUCT_KINDS = ['scalar', 'function', 'object', 'list'];

/**
 * Convenience flags for the struct factory.
 *
 * @type {Array}
 */

const STRUCT_FLAGS = ['required', 'unsealed'];

/**
 * The error codes that structs can throw.
 *
 * @type {String}
 */

const ELEMENT_INVALID = 'element_invalid';
const PROPERTY_INVALID = 'property_invalid';
const PROPERTY_REQUIRED = 'property_required';
const PROPERTY_UNKNOWN = 'property_unknown';
const VALUE_INVALID = 'value_invalid';
const VALUE_REQUIRED = 'value_required';

/**
 * Create a struct factory with a `config`.
 *
 * @param {Object} config
 * @return {Function}
 */

function superstruct(config = {}) {
  const TYPES = _extends({}, _defaultTypes2.default, config.types || {});

  /**
   * Base schema.
   *
   * @type {Schema}
   */

  class Schema {

    /**
     * Create a schema with `schema`, `defaults` and `options`.
     *
     * @param {Any} schema
     * @param {Any} defaults
     * @param {Object} options
     */

    constructor(schema, defaults, options = {}) {
      this.schema = schema;
      this.defaults = defaults;
      this.options = options;
      this.type = null;
    }

    /**
     * Assert that a `value` is valid, throwing if not.
     *
     * @param {Any} value
     * @return {Any|StructError}
     */

    assert(value) {
      const result = this.validate(value);

      if (result instanceof _structError2.default) {
        throw result;
      }

      return result;
    }

    /**
     * Get the defaulted value, given an initial `value`.
     *
     * @param {Any} value
     * @return {Any}
     */

    default(value) {
      if (value !== undefined) return value;
      const { defaults } = this;
      return typeof defaults === 'function' ? defaults() : (0, _cloneDeep2.default)(defaults);
    }

    /**
     * Test that a `value` is valid.
     *
     * @param {Any} value
     * @return {Boolean}
     */

    test(value) {
      const result = this.validate(value);
      return !(result instanceof _structError2.default);
    }

    /**
     * Validate a `value`, returning an error or the value with defaults.
     *
     * @param {Any} value
     * @return {Any|StructError}
     */

    validate(value) {
      value = this.default(value);
      return value;
    }

  }

  /**
   * Function schema.
   *
   * @type {FunctionSchema}
   */

  class FunctionSchema extends Schema {

    /**
     * Validate a `value`, returning an error or the value with defaults.
     *
     * @param {Any} value
     * @return {Any|StructError}
     */

    validate(value) {
      const { options, type, schema } = this;

      value = this.default(value);

      if (options.required && value === undefined) {
        return new _structError2.default(VALUE_REQUIRED, { type });
      }

      if (value !== undefined && !schema(value)) {
        return new _structError2.default(VALUE_INVALID, { type, value });
      }

      return value;
    }

  }

  /**
   * Scalar schema.
   *
   * @type {ScalarSchema}
   */

  class ScalarSchema extends Schema {

    /**
     * Create a scalar schema with `schema`, `defaults` and `options`.
     *
     * @param {Any} schema
     * @param {Any} defaults
     * @param {Object} options
     */

    constructor(schema, defaults, options = {}) {
      super(schema, defaults, options);

      const required = !schema.endsWith('?');
      const type = required ? schema : schema.slice(0, -1);
      const types = type.split(/\s*\|\s*/g);
      const validators = types.map(t => {
        const fn = TYPES[t];
        if (typeof fn === 'function') return fn;
        throw new Error(`No struct validator function found for type "${t}".`);
      });

      this.options.required = required;
      this.type = type;
      this.validators = validators;
    }

    /**
     * Validate a `value`, returning an error or the value with defaults.
     *
     * @param {Any} value
     * @return {Any|StructError}
     */

    validate(value) {
      const { options, type, validators } = this;

      value = this.default(value);

      if (options.required && value === undefined) {
        return new _structError2.default(VALUE_REQUIRED, { type });
      }

      if (value !== undefined && !validators.some(fn => fn(value))) {
        return new _structError2.default(VALUE_INVALID, { type, value });
      }

      return value;
    }

  }

  /**
   * List schema.
   *
   * @type {ListSchema}
   */

  class ListSchema extends Schema {

    /**
     * Create a list schema with `schema`, `defaults` and `options`.
     *
     * @param {Any} schema
     * @param {Any} defaults
     * @param {Object} options
     */

    constructor(schema, defaults, options = {}) {
      super(schema, defaults, options);

      if (schema.length !== 1) {
        throw new Error(`List structs must be defined as an array with a single element, but you passed ${schema.length} elements.`);
      }

      const type = options.required ? 'array' : 'array?';
      const valueStruct = struct(type);
      const elementStruct = struct(schema[0]);

      this.type = type;
      this.valueStruct = valueStruct;
      this.elementStruct = elementStruct;
    }

    /**
     * Validate a list `element` at `index`.
     *
     * @param {Number} index
     * @param {Any} element
     * @return {Any|StructError}
     */

    validateElement(index, element) {
      const s = this.elementStruct;
      const result = s.validate(element);

      if (result instanceof _structError2.default) {
        const e = result;
        const path = [index].concat(e.path);

        if (e.code === VALUE_INVALID) {
          return new _structError2.default(ELEMENT_INVALID, _extends({}, e, { index, path }));
        }

        if ('path' in e) e.path = path;
        return e;
      }

      return result;
    }

    /**
     * Validate a list `value`.
     *
     * @param {Any} value
     * @return {Any|StructError}
     */

    validate(value) {
      const { options, valueStruct } = this;

      value = this.default(value);
      const result = valueStruct.validate(value);

      if (result instanceof _structError2.default) {
        return result;
      }

      const errors = [];
      const values = [];
      const isUndefined = !options.required && value === undefined;
      value = isUndefined ? [] : value;

      value.forEach((e, i) => {
        const r = this.validateElement(i, e);

        if (r instanceof _structError2.default) {
          errors.push(r);
        } else {
          values.push(r);
        }
      });

      if (errors.length) {
        const first = errors[0];
        first.errors = errors;
        return first;
      }

      return isUndefined && !values.length ? undefined : values;
    }

  }

  /**
   * Object schema.
   *
   * @type {ObjectSchema}
   */

  class ObjectSchema extends Schema {

    /**
     * Create an object schema with `schema`, `defaults` and `options`.
     *
     * @param {Any} schema
     * @param {Any} defaults
     * @param {Object} options
     */

    constructor(schema, defaults, options = {}) {
      super(schema, defaults, options);

      const type = options.required ? 'object' : 'object?';
      const valueStruct = struct(type);
      const propertyStructs = {};

      for (const key in schema) {
        const s = struct(schema[key]);
        propertyStructs[key] = s;
      }

      this.type = type;
      this.valueStruct = valueStruct;
      this.propertyStructs = propertyStructs;
    }

    /**
     * Get the default value for a `key`, given an initial `value`.
     *
     * @param {String} key
     * @param {Any} value
     * @return {Any}
     */

    defaultProperty(key, value) {
      if (value !== undefined) return value;
      const { defaults = {} } = this;
      const v = defaults[key];
      return v;
    }

    /**
     * Mask the properties a `value`, returning only the known ones.
     *
     * @param {Function} Struct
     * @param {Object} value
     */

    mask(value) {
      if (value === undefined) {
        return undefined;
      }

      const { schema } = this;
      const ret = {};

      for (const key in schema) {
        if (key in value) ret[key] = value[key];
      }

      return ret;
    }

    /**
     * Validate a list `element` at `index`.
     *
     * @param {Any} element
     * @param {Number} index
     * @return {Any|StructError}
     */

    validateProperty(key, value) {
      const s = this.propertyStructs[key];

      value = this.defaultProperty(key, value);

      if (!s) {
        return new _structError2.default(PROPERTY_UNKNOWN, { key, path: [key] });
      }

      const result = s.validate(value);

      if (result instanceof _structError2.default) {
        const error = result;
        const path = [key].concat(error.path);

        if (error.code === VALUE_INVALID) {
          return new _structError2.default(PROPERTY_INVALID, _extends({}, error, { key, path }));
        }

        if (error.code === VALUE_REQUIRED) {
          return new _structError2.default(PROPERTY_REQUIRED, _extends({}, error, { key, path }));
        }

        if ('path' in error) error.path = path;
        return error;
      }

      return result;
    }

    /**
     * Validate a list `value`.
     *
     * @param {Any} value
     * @return {Any|StructError}
     */

    validate(value) {
      const { options, propertyStructs, valueStruct } = this;

      value = this.default(value);

      if (options.unsealed) {
        value = this.mask(value);
      }

      const result = valueStruct.validate(value);

      if (result instanceof _structError2.default) {
        return result;
      }

      const errors = [];
      const values = {};
      const isUndefined = !options.required && value === undefined;
      let hasKeys = false;
      value = isUndefined ? {} : value;

      for (const k in value) {
        hasKeys = true;
        const v = value[k];
        const r = this.validateProperty(k, v);

        if (r instanceof _structError2.default) {
          if (r.code === PROPERTY_REQUIRED && isUndefined) {
            return new _structError2.default(VALUE_REQUIRED, { type: 'object' });
          }

          errors.push(r);
        } else {
          values[k] = r;
        }
      }

      for (const k in propertyStructs) {
        if (k in values) continue;

        const v = value[k];
        const r = this.validateProperty(k, v);

        if (r instanceof _structError2.default) {
          if (r.code === PROPERTY_REQUIRED && isUndefined) {
            return new _structError2.default(VALUE_REQUIRED, { type: 'object' });
          }

          errors.push(r);
        }
      }

      if (errors.length) {
        const first = errors[0];
        first.errors = errors;
        return first;
      }

      return isUndefined && !hasKeys ? undefined : values;
    }

  }

  /**
   * Create a `kind` struct with schema `definition`, `defaults` and `options`.
   *
   * @param {String} kind
   * @param {Function|String|Array|Object} definition
   * @param {Any} defaults
   * @param {Object} options
   * @return {Function}
   */

  function createStruct(kind, definition, defaults, options) {
    if (isStruct(definition)) {
      return definition;
    }

    const args = [definition, defaults, options];
    let schema;

    if (kind === 'function') {
      schema = new FunctionSchema(...args);
    } else if (kind === 'scalar') {
      schema = new ScalarSchema(...args);
    } else if (kind === 'list') {
      schema = new ListSchema(...args);
    } else if (kind === 'object') {
      schema = new ObjectSchema(...args);
    } else {
      throw new Error(`Unrecognized struct kind: ${kind}`);
    }

    // Define the struct creator function.
    function Struct(data) {
      if (this instanceof Struct) {
        throw new Error('The `Struct` creation function should not be used with the `new` keyword.');
      }

      return schema.assert(data);
    }

    // Add a private property for identifying struct functions.
    Struct[IS_STRUCT] = true;

    // Mix in all of the methods for this kind of schema.
    STRUCT_METHODS.forEach(method => {
      if (schema[method]) {
        Struct[method] = (...a) => schema[method](...a);
      }
    });

    return Struct;
  }

  /**
   * Define a struct with schema `definition`, `defaults` and `options`.
   *
   * @param {Function|String|Array|Object} definition
   * @param {Any} defaults
   * @param {Object} options
   * @return {Function}
   */

  function struct(definition, defaults, options) {
    if (isStruct(definition)) {
      return definition;
    }

    const kind = getKind(definition);
    const Struct = createStruct(kind, definition, defaults, options);
    return Struct;
  }

  // Mix in a factory for each kind of struct.
  STRUCT_KINDS.forEach(kind => {
    struct[kind] = (...args) => createStruct(kind, ...args);
  });

  // Mix in the convenience properties for option flags.
  STRUCT_FLAGS.forEach(flag => {
    Object.defineProperty(struct, flag, {
      get: () => (s, d, o = {}) => struct(s, d, _extends({}, o, { [flag]: true }))
    });
  });

  /**
   * Return the struct factory.
   */

  return struct;
}

/**
 * Check if a `value` is a struct.
 *
 * @param {Any} value
 * @return {Boolean}
 */

function isStruct(value) {
  return !!(value && value[IS_STRUCT]);
}

/**
 * Get the kind of a struct from its schema `definition`.
 *
 * @param {Any} definition
 * @return {String}
 */

function getKind(definition) {
  switch ((0, _kindOf2.default)(definition)) {
    case 'function':
      return 'function';
    case 'string':
      return 'scalar';
    case 'array':
      return 'list';
    case 'object':
      return 'object';
    default:
      {
        throw new Error(`A struct schema definition must be a string, array or object, but you passed: ${definition}`);
      }
  }
}

/**
 * Export.
 *
 * @type {Function}
 */

exports.default = superstruct;

},{"./default-types":10,"./struct-error":12,"clone-deep":1,"kind-of":7}]},{},[11])(11)
});